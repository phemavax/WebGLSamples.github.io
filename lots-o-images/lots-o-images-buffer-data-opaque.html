<!--
 * Copyright 2011, Google Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->
<!doctype html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<title>Lots-O-Images - BufferData</title>
<link href="../jquery-ui-1.8.2.custom/css/ui-lightness/jquery-ui-1.8.2.custom.css" rel="stylesheet" />
<link rel="stylesheet" href="../google-io/2011/style.css" />
<style>
#fpsContainer {
    width: 200px;
}
.fps {
    white-space: pre;
}
.fps input[type=checkbox] + label {
  color: #888;
}
.fps input[type=checkbox]:checked + label {
  color: #FFF;
}
</style>
<script src="../jquery-ui-1.8.2.custom/js/jquery-1.4.2.min.js"></script>
<script src="../jquery-ui-1.8.2.custom/js/jquery-ui-1.8.2.custom.min.js"></script>
<script src="../js/perf-harness.js"></script>
<script src="../js/twgl-full.4.x.min.js"></script>
  </head>
<body>
<div id="info"><span><span id="title"></span></span></div>
<div id="fpsContainer">
  <div>target fps: <span id="targetFPS"></span></div>
  <div id="targetFPSSlider"></div>
  <div class="fps">    fps: <span id="fps"></div>
  <div class="fps">avg-fps: <span id="afps"></div>
  <div class="fps">  count: <span id="cnt"></span></div>
  <hr>
</div>
<div id="viewContainer">
<canvas id="canvas" width="512" height="512" style="width: 100%; height: 100%;"></canvas>
</div>
</body>
<script>
'use strict';

/* global twgl, PerfHarness */

const vs = `
uniform vec2 dimensions;
attribute vec2 position;
attribute vec2 texCoord;
attribute vec2 worldPosition;
attribute vec4 colorMult;
varying vec2 v_texCoord;
varying vec4 v_colorMult;
void main() {
  v_texCoord = texCoord;
  v_colorMult = colorMult;
  gl_Position = vec4(
    (((position + worldPosition) / dimensions) * 2.0 - 1.0) * vec2(1, -1), 0, 1);
}
`;
const fs = `
precision mediump float;
varying vec2 v_texCoord;
varying vec4 v_colorMult;

uniform sampler2D diffuseSampler;

void main() {
  gl_FragColor = texture2D(diffuseSampler, v_texCoord) * v_colorMult;
}
`;

// globals
let gl;                   // the gl context.
let canvas;               // the canvas
let g_maxImages = 0;
let g_numImages = 0;
const g_imageSize = 32;

const query = new URLSearchParams(window.location.search);
function getQueryBool(id) {
  const value = (query.get(id) || '').toLowerCase();
  return value === 'true' || value === '1';
}

function createApp(settings) {
  function r(min, max) {
    if (max === undefined) {
      max = min;
      min = 0;
    }
    return Math.random() * (max - min) + min;
  }

  const numVertsPerPlane = 4;
  const numPlanesPerBuffer = 65536 / numVertsPerPlane;
  const positions = [];
  const texcoords = [];
  const colors = [];
  const indices = [];
  for (let i = 0; i < numPlanesPerBuffer; ++i) {
    positions.push(0, 0, 32, 0, 0, 32, 32, 32);
    texcoords.push(.0, 0, 1, 0, 0, 1, 1, 1);
    const color = [r(1), r(1), r(1), r(0.5, 1)];
    colors.push(...color, ...color, ...color, ...color);
    const ndx = i * 4;
    indices.push(
        ndx    , ndx + 1, ndx + 2,
        ndx + 2, ndx + 1, ndx + 3);
  }

  function createBuffer(gl, data, Type, target) {
    target = target || gl.ARRAY_BUFFER;
    Type = Type || Float32Array;
    const buf = gl.createBuffer();
    gl.bindBuffer(target, buf);
    gl.bufferData(target, new Type(data), gl.STATIC_DRAW);
    return buf;
  }

  const positionBuffer = createBuffer(gl, positions);
  const texcoordBuffer = createBuffer(gl, texcoords);
  const indexBuffer = createBuffer(gl, indices, Uint16Array, gl.ELEMENT_ARRAY_BUFFER);

  function createInstanceSet(gl) {
    const instances = [];
    for (let i = 0; i < numPlanesPerBuffer; ++i) {
      instances.push({
        x: r(gl.canvas.width),
        y: r(gl.canvas.height),
        xVel: Math.sign(r(-1000, 1000)) * 60,
        yVel: Math.sign(r(-1000, 1000)) * 60,
        firstVertex: i * numVertsPerPlane,
        numVertices: numVertsPerPlane,
      });
    }
    return {
      instances,
      colorBuffer: createBuffer(gl, colors),
      worldPositionBuffer: createBuffer(gl, positions),
      worldPosition: new Float32Array(positions.length),
    };
  }

  const instanceSets = [];

  function addInstanceSet(gl) {
    const instanceSet = createInstanceSet(gl);
    instanceSets.push(instanceSet);
    g_maxImages += instanceSet.instances.length;
  }

  const textures = twgl.createTexture(gl, {
    src: '../google-io/2011/assets/google.png',
  });

  const program = twgl.createProgram(gl, [vs, fs]);
  const positionLoc = gl.getAttribLocation(program, 'position');
  const texcoordLoc = gl.getAttribLocation(program, 'texCoord');
  const worldPositionLoc = gl.getAttribLocation(program, 'worldPosition');
  const colorLoc = gl.getAttribLocation(program, 'colorMult');
  const dimensionsLoc = gl.getUniformLocation(program, 'dimensions');

  function fillRange(dst, offset, count, x, y) {
    for (let i = 0; i < count; ++i) {
      dst[offset++] = x;
      dst[offset++] = y;
    }
  }

  function update(elapsedTime) {
    twgl.resizeCanvasToDisplaySize(gl.canvas);

    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

    while (g_maxImages < g_numImages) {
      addInstanceSet(gl);
    }

    // --Update Instance Positions---------------------------------------
    if (settings.update) {
      const width = canvas.clientWidth - g_imageSize;
      const height = canvas.clientHeight - g_imageSize;
      const advance = elapsedTime;
      const numSets = Math.ceil(g_numImages / numPlanesPerBuffer);
      for (let setNdx = 0; setNdx < numSets; ++setNdx) {
        const {instances, worldPosition, worldPositionBuffer} = instanceSets[setNdx];
        const numImages = Math.min(numPlanesPerBuffer, g_numImages - setNdx * numPlanesPerBuffer)
        for (let ii = 0; ii < numImages; ++ii) {
          const instance = instances[ii];
          instance.x += advance * instance.xVel;
          instance.y += advance * instance.yVel;
          if (instance.x < 0) {
            instance.x = 0;
            instance.xVel = Math.abs(instance.xVel);
          } else if (instance.x > width) {
            instance.x = width;
            instance.xVel = -Math.abs(instance.xVel);
          }
          if (instance.y < 0) {
            instance.y = 0;
            instance.yVel = Math.abs(instance.yVel);
          } else if (instance.y > height) {
            instance.y = height;
            instance.yVel = -Math.abs(instance.yVel);
          }
          fillRange(worldPosition, instance.firstVertex * 2, instance.numVertices, instance.x, instance.y);
        }
        gl.bindBuffer(gl.ARRAY_BUFFER, worldPositionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, worldPosition, gl.DYNAMIC_DRAW);
      }
    }
  }

  function render() {
    renderBegin();
    renderScene();
    renderEnd();
  }

  function renderBegin() {
    gl.colorMask(true, true, true, true);
    gl.clearColor(1, 1, 1, 1);
    gl.clear(gl.COLOR_BUFFER_BIT);

    if (settings.blend) {
      gl.enable(gl.BLEND);
      gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
    }
  }

  function renderScene() {
    gl.useProgram(program);

    gl.uniform2f(dimensionsLoc, gl.canvas.width, gl.canvas.height);
    
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.enableVertexAttribArray(positionLoc);
    gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);

    gl.bindBuffer(gl.ARRAY_BUFFER, texcoordBuffer);
    gl.enableVertexAttribArray(texcoordLoc);
    gl.vertexAttribPointer(texcoordLoc, 2, gl.FLOAT, false, 0, 0);

    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);

    const numSets = Math.ceil(g_numImages / numPlanesPerBuffer);
    for (let setNdx = 0; setNdx < numSets; ++setNdx) {
      const {colorBuffer, worldPositionBuffer} = instanceSets[setNdx];
      const numImages = Math.min(numPlanesPerBuffer, g_numImages - setNdx * numPlanesPerBuffer);

      gl.bindBuffer(gl.ARRAY_BUFFER, worldPositionBuffer);
      gl.enableVertexAttribArray(worldPositionLoc);
      gl.vertexAttribPointer(worldPositionLoc, 2, gl.FLOAT, false, 0, 0);

      gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
      gl.enableVertexAttribArray(colorLoc);
      gl.vertexAttribPointer(colorLoc, 4, gl.FLOAT, false, 0, 0);

      gl.drawElements(gl.TRIANGLES, numImages * 6, gl.UNSIGNED_SHORT, 0);
    }
  }

  function renderEnd() {
    // nothing to do.
  }

  return {
    update: update,
    render: render,
  };
}

function createElem(tag, attrs = {}) {
  const elem = document.createElement(tag);
  for (const [key, value] of Object.entries(attrs)) {
    if (typeof value === 'object') {
      for (const [k, v] of Object.entries(value)) {
        try {
        elem[key][k] = v;
        } catch (e) {
          debugger;  // eslint-disable-line no-debugger
        }
      }
    } else if (elem[key] === undefined) {
      elem.setAttribute(key, value);
    } else {
      elem[key] = value;
    }
  }
  return elem;
}

function addElem(tag, parent, attrs = {}) {
  const elem = createElem(tag, attrs);
  parent.appendChild(elem);
  return elem;
}

function noop() {
}

function addBool(parent, object, propertyName, callback = noop) {
  const div = addElem('div', parent, {className:'fps'});
  const id = `input-${performance.now()}-${Math.random() * 100000 | 0}`;
  const input = addElem('input', div, {
    type: 'checkbox',
    id,
    checked: object[propertyName],
  });
  addElem('label', div, {
    for: id,
    textContent: propertyName,
  });
  input.addEventListener('input', (e) => {
    const v = input.checked;
    object[propertyName] = v;
    callback(v);
  });
}

function initialize() {
  canvas = document.getElementById("canvas");
  const fpsElem = document.getElementById("fps");
  const afpsElem = document.getElementById("afps");
  const velElem = document.getElementById("vel");
  const cntElem = document.getElementById("cnt");
  const acntElem = document.getElementById("acnt");
  const targetFPSElem = document.getElementById("targetFPS");

  const settings =  {
    alpha: getQueryBool('alpha'),
    antialias: getQueryBool('antialias'),
    preserveDrawingBuffer: getQueryBool('preserveDrawingBuffer'),
    blend: getQueryBool('blend'),
    update: true,
  };

  function reload() {
    const s = new URLSearchParams();
    s.set('alpha', settings.alpha);
    s.set('antialias', settings.antialias);
    s.set('preserveDrawingBuffer', settings.preserveDrawingBuffer);
    s.set('blend', settings.blend);
    window.location.search = s.toString();
  }

  const fpsContainer = document.querySelector('#fpsContainer');
  addBool(fpsContainer, settings, 'alpha', reload);
  addBool(fpsContainer, settings, 'preserveDrawingBuffer', reload);
  addBool(fpsContainer, settings, 'antialias', reload);
  addBool(fpsContainer, settings, 'blend');
  addBool(fpsContainer, settings, 'update');

  const targetFPS = 55;

  const setTargetFPS = function(targetFPS) {
    PerfHarness.setTargetFPS(targetFPS);
    targetFPSElem.innerHTML = targetFPS;
  };

  $("#targetFPSSlider").slider({
    max: 60,
    min: 1,
    value: targetFPS,
    slide: function(event, ui) {
      setTargetFPS(ui.value);
    },
  });
  setTargetFPS(targetFPS);

  document.getElementById("title").innerHTML = document.getElementsByTagName("title")[0].innerHTML;

  const ctxOptions = {
    alpha: settings.alpha,
    antialias: settings.antialias,
    preserveDrawingBuffer: settings.preserveDrawingBuffer,
  };
  gl = canvas.getContext('webgl', ctxOptions);
  if (!gl) {
    return false;
  }

  const app = createApp(settings);

  const elapsedTimeHistory = new Array(10).fill(0);
  let elapsedTimeTotal = 0;
  let elapsedTimeHistoryCursor = 0;
  let elapsedTimeAverage = 0;
  let direction = 1;

  function updateElapsedTimeHistory(elapsedTime) {
    elapsedTimeTotal += elapsedTime - elapsedTimeHistory[elapsedTimeHistoryCursor];
    elapsedTimeHistory[elapsedTimeHistoryCursor++] = elapsedTime;
    elapsedTimeHistoryCursor %= elapsedTimeHistory.length;
    elapsedTimeAverage = elapsedTimeTotal / elapsedTimeHistory.length;
  }

  const numFramesForStable = 1;
  let lastDirection = 1;
  let sameDirectionCount = 0;
  let lastCount = 0;
  let directionMark;
  function trackCount(count) {
    const direction = Math.sign(count - lastCount);
    if (direction !== lastDirection) {
      sameDirectionCount = 0;
    } else {
      ++sameDirectionCount;
    }
    lastDirection = direction;
    if (sameDirectionCount < numFramesForStable) {
      directionMark = "-";
    } else {
      directionMark = direction > 0 ? '^' : 'v';
    }
  }

  function render(count, averageCount, elapsedTime, velocity) {
    updateElapsedTimeHistory(elapsedTime);
    trackCount(count);

    // Update the FPS timer.
    fpsElem.textContent = 1 / elapsedTime | 0;
    afpsElem.textContent = 1 / elapsedTimeAverage | 0;

    g_numImages = count;
    cntElem.textContent = `${count}${directionMark}`;

    app.update(elapsedTime);
    app.render();
  }
  PerfHarness.start(canvas, render, 60);
  return true;
}

initialize();
</script>
</html>




